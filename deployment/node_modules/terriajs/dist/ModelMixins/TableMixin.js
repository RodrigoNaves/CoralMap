var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import i18next from "i18next";
import { action, computed, observable, runInAction } from "mobx";
import { createTransformer } from "mobx-utils";
import DeveloperError from "terriajs-cesium/Source/Core/DeveloperError";
import JulianDate from "terriajs-cesium/Source/Core/JulianDate";
import Rectangle from "terriajs-cesium/Source/Core/Rectangle";
import TimeInterval from "terriajs-cesium/Source/Core/TimeInterval";
import CustomDataSource from "terriajs-cesium/Source/DataSources/CustomDataSource";
import DataSource from "terriajs-cesium/Source/DataSources/DataSource";
import ImageryLayerFeatureInfo from "terriajs-cesium/Source/Scene/ImageryLayerFeatureInfo";
import getChartColorForId from "../Charts/getChartColorForId";
import filterOutUndefined from "../Core/filterOutUndefined";
import isDefined from "../Core/isDefined";
import { isLatLonHeight } from "../Core/LatLonHeight";
import makeRealPromise from "../Core/makeRealPromise";
import TerriaError from "../Core/TerriaError";
import ConstantColorMap from "../Map/ConstantColorMap";
import MapboxVectorTileImageryProvider from "../Map/MapboxVectorTileImageryProvider";
import JSRegionProviderList from "../Map/RegionProviderList";
import CommonStrata from "../Models/Definition/CommonStrata";
import createLongitudeLatitudeFeaturePerId from "../Table/createLongitudeLatitudeFeaturePerId";
import createLongitudeLatitudeFeaturePerRow from "../Table/createLongitudeLatitudeFeaturePerRow";
import getChartDetailsFn from "../Table/getChartDetailsFn";
import TableColumn from "../Table/TableColumn";
import TableColumnType from "../Table/TableColumnType";
import TableStyle from "../Table/TableStyle";
import CatalogMemberMixin from "./CatalogMemberMixin";
import ChartableMixin, { calculateDomain } from "./ChartableMixin";
import DiscretelyTimeVaryingMixin from "./DiscretelyTimeVaryingMixin";
import ExportableMixin from "./ExportableMixin";
// TypeScript 3.6.3 can't tell JSRegionProviderList is a class and reports
//   Cannot use namespace 'JSRegionProviderList' as a type.ts(2709)
// This is a dodgy workaround.
class RegionProviderList extends JSRegionProviderList {
}
function TableMixin(Base) {
    class TableMixin extends ExportableMixin(ChartableMixin(DiscretelyTimeVaryingMixin(CatalogMemberMixin(Base)))) {
        constructor() {
            super(...arguments);
            this.createLongitudeLatitudeDataSource = createTransformer((style) => {
                if (!style.isPoints()) {
                    return undefined;
                }
                const dataSource = new CustomDataSource(this.name || "Table");
                dataSource.entities.suspendEvents();
                let features;
                if (style.isTimeVaryingPointsWithId()) {
                    features = createLongitudeLatitudeFeaturePerId(style);
                }
                else {
                    features = createLongitudeLatitudeFeaturePerRow(style);
                }
                // _catalogItem property is needed for some feature picking functions (eg FeatureInfoMixin)
                features.forEach(f => {
                    f._catalogItem = this;
                    dataSource.entities.add(f);
                });
                dataSource.show = this.show;
                dataSource.entities.resumeEvents();
                return dataSource;
            });
            this.createRegionMappedImageryProvider = createTransformer((input) => {
                if (!input.style.isRegions()) {
                    return undefined;
                }
                const regionColumn = input.style.regionColumn;
                const regionType = regionColumn.regionType;
                if (regionType === undefined) {
                    return undefined;
                }
                const baseMapContrastColor = "white"; //this.terria.baseMapContrastColor;
                const colorColumn = input.style.colorColumn;
                const valueFunction = colorColumn !== undefined
                    ? colorColumn.valueFunctionForType
                    : () => null;
                const colorMap = (this.activeTableStyle || this.defaultTableStyle)
                    .colorMap;
                const valuesAsRegions = regionColumn.valuesAsRegions;
                let currentTimeRows;
                // TODO: this is already implemented in RegionProvider.prototype.mapRegionsToIndicesInto, but regionTypes require "loading" for this to work. I think the whole RegionProvider thing needs to be re-done in TypeScript at some point and then we can move stuff into that.
                // If time varying, get row indices which match
                if (input.currentTime &&
                    input.style.timeIntervals &&
                    input.style.moreThanOneTimeInterval) {
                    currentTimeRows = input.style.timeIntervals.reduce((rows, timeInterval, index) => {
                        if (timeInterval &&
                            TimeInterval.contains(timeInterval, input.currentTime)) {
                            rows.push(index);
                        }
                        return rows;
                    }, []);
                }
                const catalogItem = this;
                return new MapboxVectorTileImageryProvider({
                    url: regionType.server,
                    layerName: regionType.layerName,
                    styleFunc: function (feature) {
                        const featureRegion = feature.properties[regionType.regionProp];
                        const regionIdString = featureRegion !== undefined && featureRegion !== null
                            ? featureRegion.toString()
                            : "";
                        let rowNumber = catalogItem.getImageryLayerFilteredRows(input, currentTimeRows, valuesAsRegions.regionIdToRowNumbersMap.get(regionIdString.toLowerCase()));
                        let value = isDefined(rowNumber)
                            ? valueFunction(rowNumber)
                            : null;
                        const color = colorMap.mapValueToColor(value);
                        if (color === undefined) {
                            return undefined;
                        }
                        return {
                            fillStyle: color.toCssColorString(),
                            strokeStyle: baseMapContrastColor,
                            lineWidth: 1,
                            lineJoin: "miter"
                        };
                    },
                    subdomains: regionType.serverSubdomains,
                    rectangle: Array.isArray(regionType.bbox) && regionType.bbox.length >= 4
                        ? Rectangle.fromDegrees(regionType.bbox[0], regionType.bbox[1], regionType.bbox[2], regionType.bbox[3])
                        : undefined,
                    minimumZoom: regionType.serverMinZoom,
                    maximumNativeZoom: regionType.serverMaxNativeZoom,
                    maximumZoom: regionType.serverMaxZoom,
                    uniqueIdProp: regionType.uniqueIdProp,
                    featureInfoFunc: (feature) => this.getImageryLayerFeatureInfo(input, feature, currentTimeRows)
                });
            });
            this.getTableColumn = createTransformer((index) => {
                return new TableColumn(this, index);
            });
            this.getTableStyle = createTransformer((index) => {
                return new TableStyle(this, index);
            });
        }
        get hasTableMixin() {
            return true;
        }
        /**
         * The raw data table in column-major format, i.e. the outer array is an
         * array of columns.
         */
        get dataColumnMajor() {
            const dataColumnMajor = this._dataColumnMajor;
            if (this.removeDuplicateRows &&
                dataColumnMajor !== undefined &&
                dataColumnMajor.length >= 1) {
                // De-duplication is slow and memory expensive, so should be avoided if possible.
                const rowsToRemove = new Set();
                const seenRows = new Set();
                for (let i = 0; i < dataColumnMajor[0].length; i++) {
                    const row = dataColumnMajor.map(col => col[i]).join();
                    if (seenRows.has(row)) {
                        // Mark row for deletion
                        rowsToRemove.add(i);
                    }
                    else {
                        seenRows.add(row);
                    }
                }
                if (rowsToRemove.size > 0) {
                    return dataColumnMajor.map(col => col.filter((cell, idx) => !rowsToRemove.has(idx)));
                }
            }
            return dataColumnMajor;
        }
        set dataColumnMajor(newDataColumnMajor) {
            this._dataColumnMajor = newDataColumnMajor;
        }
        /**
         * Gets a {@link TableColumn} for each of the columns in the raw data.
         */
        get tableColumns() {
            if (this.dataColumnMajor === undefined) {
                return [];
            }
            return this.dataColumnMajor.map((_, i) => this.getTableColumn(i));
        }
        /**
         * Gets a {@link TableStyle} for each of the {@link styles}. If there
         * are no styles, returns an empty array.
         */
        get tableStyles() {
            if (this.styles === undefined) {
                return [];
            }
            return this.styles.map((_, i) => this.getTableStyle(i));
        }
        /**
         * Gets the default {@link TableStyle}, which is used for styling
         * only when there are no styles defined.
         */
        get defaultTableStyle() {
            return new TableStyle(this, -1);
        }
        /**
         * Gets the {@link TableStyleTraits#id} of the currently-active style.
         * Note that this is a trait so there is no guarantee that a style
         * with this ID actually exists. If no active style is explicitly
         * specified, the ID of the first style with a scalar color column is used.
         * If there is no such style the id of the first style of the {@link #styles}
         * is used.
         */
        get activeStyle() {
            const value = super.activeStyle;
            if (value !== undefined) {
                return value;
            }
            else if (this.styles && this.styles.length > 0) {
                // Find and return a style with scalar color column if it exists,
                // otherwise just return the first available style id.
                const styleWithScalarColorColumn = this.styles.find(s => {
                    var _a;
                    const colName = s.color.colorColumn;
                    return (colName &&
                        ((_a = this.findColumnByName(colName)) === null || _a === void 0 ? void 0 : _a.type) === TableColumnType.scalar);
                });
                return (styleWithScalarColorColumn === null || styleWithScalarColorColumn === void 0 ? void 0 : styleWithScalarColorColumn.id) || this.styles[0].id;
            }
            return undefined;
        }
        /**
         * Gets the active {@link TableStyle}, which is the item from {@link #tableStyles}
         * with an ID that matches {@link #activeStyle}, if any.
         */
        get activeTableStyle() {
            const activeStyle = this.activeStyle;
            if (activeStyle === undefined) {
                return this.defaultTableStyle;
            }
            let ret = this.tableStyles.find(style => style.id === this.activeStyle);
            if (ret === undefined) {
                return this.defaultTableStyle;
            }
            return ret;
        }
        get xColumn() {
            return this.activeTableStyle.xAxisColumn;
        }
        get yColumns() {
            const lines = this.activeTableStyle.chartTraits.lines;
            return filterOutUndefined(lines.map(line => line.yAxisColumn === undefined
                ? undefined
                : this.findColumnByName(line.yAxisColumn)));
        }
        get disableOpacityControl() {
            // disable opacity control for point tables - or if no mapItems
            return this.activeTableStyle.isPoints() || this.mapItems.length === 0;
        }
        get _canExportData() {
            return isDefined(this.dataColumnMajor);
        }
        async _exportData() {
            if (isDefined(this.dataColumnMajor)) {
                // I am assuming all columns have the same length -> so use first column
                let csvString = this.dataColumnMajor[0]
                    .map((row, rowIndex) => this.dataColumnMajor.map(col => col[rowIndex]).join(","))
                    .join("\n");
                return {
                    name: (this.name || this.uniqueId),
                    file: new Blob([csvString])
                };
            }
            throw new TerriaError({
                sender: this,
                message: "No data available to download."
            });
        }
        get disableSplitter() {
            return !isDefined(this.activeTableStyle.regionColumn);
        }
        get disableZoomTo() {
            // Disable zoom if only showing imagery parts  (eg region mapping) and no rectangle is defined
            if (!this.mapItems.find(m => m instanceof DataSource) &&
                !isDefined(this.cesiumRectangle)) {
                return true;
            }
            return super.disableZoomTo;
        }
        /**
         * Gets the items to show on the map.
         */
        get mapItems() {
            var _a, _b, _c, _d;
            const numRegions = (_d = (_c = (_b = (_a = this.activeTableStyle.regionColumn) === null || _a === void 0 ? void 0 : _a.valuesAsRegions) === null || _b === void 0 ? void 0 : _b.uniqueRegionIds) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
            // Estimate number of points based off number of rowGroups
            const numPoints = this.activeTableStyle.rowGroups.length;
            // If we have more points than regions OR we have points are are using a ConstantColorMap - show points instead of regions
            // (Using ConstantColorMap with regions will result in all regions being the same color - which isn't useful)
            if ((numPoints > 0 &&
                this.activeTableStyle.colorMap instanceof ConstantColorMap) ||
                numPoints > numRegions) {
                const pointsDataSource = this.createLongitudeLatitudeDataSource(this.activeTableStyle);
                // Make sure there are actually more points than regions
                if (pointsDataSource &&
                    pointsDataSource.entities.values.length > numRegions)
                    return [pointsDataSource];
            }
            if (this.regionMappedImageryParts)
                return [this.regionMappedImageryParts];
            return [];
        }
        get shortReport() {
            return this.mapItems.length === 0 &&
                this.chartItems.length === 0 &&
                !this.isLoading
                ? i18next.t("models.tableData.noData")
                : super.shortReport;
        }
        // regionMappedImageryParts and regionMappedImageryProvider are split up like this so that we aren't re-creating the imageryProvider if things like `opacity` and `show` change
        get regionMappedImageryParts() {
            if (!this.regionMappedImageryProvider)
                return;
            return {
                imageryProvider: this.regionMappedImageryProvider,
                alpha: this.opacity,
                show: this.show,
                clippingRectangle: this.clipToRectangle
                    ? this.cesiumRectangle
                    : undefined
            };
        }
        get regionMappedImageryProvider() {
            return this.createRegionMappedImageryProvider({
                style: this.activeTableStyle,
                currentTime: this.currentDiscreteJulianDate
            });
        }
        /**
         * Try to resolve `regionType` to a region provider (this will also match against region provider aliases)
         */
        matchRegionType(regionType) {
            var _a;
            if (!isDefined(regionType))
                return;
            const matchingRegionProviders = (_a = this.regionProviderList) === null || _a === void 0 ? void 0 : _a.getRegionDetails([regionType], undefined, undefined);
            if (matchingRegionProviders && matchingRegionProviders.length > 0) {
                return matchingRegionProviders[0].regionProvider.regionType;
            }
        }
        /**
         * Gets the items to show on a chart.
         *
         */
        get tableChartItems() {
            const style = this.activeTableStyle;
            if (style === undefined || !style.isChart()) {
                return [];
            }
            const xColumn = style.xAxisColumn;
            const lines = style.chartTraits.lines;
            if (xColumn === undefined || lines.length === 0) {
                return [];
            }
            const xValues = xColumn.type === TableColumnType.time
                ? xColumn.valuesAsDates.values
                : xColumn.valuesAsNumbers.values;
            const xAxis = {
                scale: xColumn.type === TableColumnType.time ? "time" : "linear",
                units: xColumn.units
            };
            return filterOutUndefined(lines.map(line => {
                var _a, _b;
                const yColumn = line.yAxisColumn
                    ? this.findColumnByName(line.yAxisColumn)
                    : undefined;
                if (yColumn === undefined) {
                    return undefined;
                }
                const yValues = yColumn.valuesAsNumbers.values;
                const points = [];
                for (let i = 0; i < xValues.length; ++i) {
                    const x = xValues[i];
                    const y = yValues[i];
                    if (x === null || y === null) {
                        continue;
                    }
                    points.push({ x, y });
                }
                if (points.length <= 1)
                    return;
                const colorId = `color-${this.uniqueId}-${this.name}-${yColumn.name}`;
                return {
                    item: this,
                    name: (_a = line.name) !== null && _a !== void 0 ? _a : yColumn.title,
                    categoryName: this.name,
                    key: `key${this.uniqueId}-${this.name}-${yColumn.name}`,
                    type: (_b = this.chartType) !== null && _b !== void 0 ? _b : "line",
                    xAxis,
                    points,
                    domain: calculateDomain(points),
                    units: yColumn.units,
                    isSelectedInWorkbench: line.isSelectedInWorkbench,
                    showInChartPanel: this.show && line.isSelectedInWorkbench,
                    updateIsSelectedInWorkbench: (isSelected) => {
                        runInAction(() => {
                            line.setTrait(CommonStrata.user, "isSelectedInWorkbench", isSelected);
                        });
                    },
                    getColor: () => {
                        return line.color || getChartColorForId(colorId);
                    },
                    pointOnMap: isLatLonHeight(this.chartPointOnMap)
                        ? this.chartPointOnMap
                        : undefined
                };
            }));
        }
        get chartItems() {
            var _a;
            return filterOutUndefined([
                // If time-series region mapping - show time points chart
                this.activeTableStyle.isRegions() && ((_a = this.discreteTimes) === null || _a === void 0 ? void 0 : _a.length)
                    ? this.momentChart
                    : undefined,
                ...this.tableChartItems
            ]);
        }
        get selectableDimensions() {
            return filterOutUndefined([
                ...super.selectableDimensions,
                this.regionColumnDimensions,
                this.regionProviderDimensions,
                this.styleDimensions
            ]);
        }
        /**
         * Takes {@link TableStyle}s and returns a SelectableDimension which can be rendered in a Select dropdown
         */
        get styleDimensions() {
            if (this.mapItems.length === 0 && !this.enableManualRegionMapping) {
                return;
            }
            return {
                id: "activeStyle",
                name: "Display Variable",
                options: this.tableStyles
                    .filter(style => !style.hidden || this.activeStyle === style.id)
                    .map(style => {
                    return {
                        id: style.id,
                        name: style.title
                    };
                }),
                selectedId: this.activeStyle,
                setDimensionValue: (stratumId, styleId) => {
                    this.setTrait(stratumId, "activeStyle", styleId);
                }
            };
        }
        /**
         * Creates SelectableDimension for regionProviderList - the list of all available region providers.
         * {@link TableTraits#enableManualRegionMapping} must be enabled.
         */
        get regionProviderDimensions() {
            var _a, _b, _c;
            if (!this.enableManualRegionMapping ||
                !Array.isArray((_a = this.regionProviderList) === null || _a === void 0 ? void 0 : _a.regionProviders) ||
                !isDefined(this.activeTableStyle.regionColumn)) {
                return;
            }
            return {
                id: "regionMapping",
                name: "Region Mapping",
                options: this.regionProviderList.regionProviders.map(regionProvider => {
                    return {
                        name: regionProvider.regionType,
                        id: regionProvider.regionType
                    };
                }),
                allowUndefined: true,
                selectedId: (_c = (_b = this.activeTableStyle.regionColumn) === null || _b === void 0 ? void 0 : _b.regionType) === null || _c === void 0 ? void 0 : _c.regionType,
                setDimensionValue: (stratumId, regionType) => {
                    var _a;
                    let columnTraits = (_a = this.columns) === null || _a === void 0 ? void 0 : _a.find(column => { var _a; return column.name === ((_a = this.activeTableStyle.regionColumn) === null || _a === void 0 ? void 0 : _a.name); });
                    if (!isDefined(columnTraits)) {
                        columnTraits = this.addObject(stratumId, "columns", this.activeTableStyle.regionColumn.name);
                        columnTraits.setTrait(stratumId, "name", this.activeTableStyle.regionColumn.name);
                    }
                    columnTraits.setTrait(stratumId, "regionType", regionType);
                }
            };
        }
        /**
         * Creates SelectableDimension for region column - the options contains a list of all columns.
         * {@link TableTraits#enableManualRegionMapping} must be enabled.
         */
        get regionColumnDimensions() {
            var _a, _b;
            if (!this.enableManualRegionMapping ||
                !Array.isArray((_a = this.regionProviderList) === null || _a === void 0 ? void 0 : _a.regionProviders)) {
                return;
            }
            return {
                id: "regionColumn",
                name: "Region Column",
                options: this.tableColumns.map(col => {
                    return {
                        name: col.name,
                        id: col.name
                    };
                }),
                selectedId: (_b = this.activeTableStyle.regionColumn) === null || _b === void 0 ? void 0 : _b.name,
                setDimensionValue: (stratumId, regionCol) => {
                    this.defaultStyle.setTrait(stratumId, "regionColumn", regionCol);
                }
            };
        }
        get rowIds() {
            var _a, _b;
            const nRows = (((_b = (_a = this.dataColumnMajor) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.length) || 1) - 1;
            const ids = [...new Array(nRows).keys()];
            return ids;
        }
        get isSampled() {
            return this.activeTableStyle.isSampled;
        }
        get discreteTimes() {
            var _a;
            if (!this.activeTableStyle.moreThanOneTimeInterval)
                return;
            const dates = (_a = this.activeTableStyle.timeColumn) === null || _a === void 0 ? void 0 : _a.valuesAsDates.values;
            if (dates === undefined) {
                return;
            }
            const times = filterOutUndefined(dates.map(d => d ? { time: d.toISOString(), tag: undefined } : undefined)).reduce(
            // is it correct for discrete times to remove duplicates?
            // see discussion on https://github.com/TerriaJS/terriajs/pull/4577
            // duplicates will mess up the indexing problem as our `<DateTimePicker />`
            // will eliminate duplicates on the UI front, so given the datepicker
            // expects uniques, return uniques here
            (acc, time) => !acc.some(accTime => accTime.time === time.time && accTime.tag === time.tag)
                ? [...acc, time]
                : acc, []);
            return times;
        }
        get legends() {
            if (this.mapItems.length > 0) {
                const colorLegend = this.activeTableStyle.colorTraits.legend;
                return filterOutUndefined([colorLegend]);
            }
            else {
                return [];
            }
        }
        findFirstColumnByType(type) {
            return this.tableColumns.find(column => column.type === type);
        }
        findColumnByName(name) {
            return this.tableColumns.find(column => column.name === name);
        }
        async forceLoadMapItems() {
            const dataColumnMajor = await this.forceLoadTableData();
            if (dataColumnMajor !== undefined && dataColumnMajor !== null) {
                runInAction(() => {
                    this.dataColumnMajor = dataColumnMajor;
                });
            }
        }
        async loadRegionProviderList() {
            if (isDefined(this.regionProviderList))
                return;
            const regionProvidersPromise = await makeRealPromise(RegionProviderList.fromUrl(this.terria.configParameters.regionMappingDefinitionsUrl, this.terria.corsProxy));
            runInAction(() => (this.regionProviderList = regionProvidersPromise));
        }
        /*
         * Appends new table data in column major format to this table.
         * It is assumed that the column order is the same for both the tables.
         */
        append(dataColumnMajor2) {
            if (this.dataColumnMajor !== undefined &&
                this.dataColumnMajor.length !== dataColumnMajor2.length) {
                throw new DeveloperError("Cannot add tables with different numbers of columns.");
            }
            const appended = this.dataColumnMajor || [];
            dataColumnMajor2.forEach((newRows, col) => {
                if (appended[col] === undefined) {
                    appended[col] = [];
                }
                appended[col].push(...newRows);
            });
            this.dataColumnMajor = appended;
        }
        /**
         * Filters row numbers by time (if applicable) - for a given region mapped ImageryLayer
         */
        getImageryLayerFilteredRows(input, currentTimeRows, rowNumbers) {
            if (!isDefined(rowNumbers))
                return;
            if (!isDefined(currentTimeRows)) {
                return Array.isArray(rowNumbers) ? rowNumbers[0] : rowNumbers;
            }
            if (typeof rowNumbers === "number" &&
                currentTimeRows.includes(rowNumbers)) {
                return rowNumbers;
            }
            else if (Array.isArray(rowNumbers)) {
                const matchingTimeRows = rowNumbers.filter(row => currentTimeRows.includes(row));
                if (matchingTimeRows.length <= 1) {
                    return matchingTimeRows[0];
                }
                //In a time-varying dataset, intervals may
                // overlap at their endpoints (i.e. the end of one interval is the start of the next).
                // In that case, we want the later interval to apply.
                return matchingTimeRows.reduce((latestRow, currentRow) => {
                    var _a, _b, _c, _d;
                    const currentInterval = (_b = (_a = input.style.timeIntervals) === null || _a === void 0 ? void 0 : _a[currentRow]) === null || _b === void 0 ? void 0 : _b.stop;
                    const latestInterval = (_d = (_c = input.style.timeIntervals) === null || _c === void 0 ? void 0 : _c[latestRow]) === null || _d === void 0 ? void 0 : _d.stop;
                    if (currentInterval &&
                        latestInterval &&
                        JulianDate.lessThan(latestInterval, currentInterval)) {
                        return currentRow;
                    }
                    return latestRow;
                }, matchingTimeRows[0]);
            }
        }
        /**
         * Get ImageryLayerFeatureInfo for a given ImageryLayer input and feature.
         */
        getImageryLayerFeatureInfo(input, feature, currentTimeRows) {
            var _a;
            if (isDefined(input.style.regionColumn) &&
                isDefined(input.style.regionColumn.regionType) &&
                isDefined(input.style.regionColumn.regionType.regionProp)) {
                const regionType = input.style.regionColumn.regionType;
                if (!isDefined(regionType))
                    return undefined;
                const regionIds = (_a = input.style.regionColumn.valuesAsRegions.regionIdToRowNumbersMap.get(feature.properties[regionType.regionProp].toLowerCase())) !== null && _a !== void 0 ? _a : [];
                const filteredRegionId = this.getImageryLayerFilteredRows(input, currentTimeRows, regionIds);
                let d = isDefined(filteredRegionId)
                    ? this.getRowValues(filteredRegionId)
                    : null;
                if (d === null)
                    return;
                // Preserve values from d and insert feature properties after entries from d
                const featureData = Object.assign({}, d, feature.properties, d);
                const featureInfo = new ImageryLayerFeatureInfo();
                if (isDefined(regionType.nameProp)) {
                    featureInfo.name = featureData[regionType.nameProp];
                }
                featureData.id = feature.properties[regionType.uniqueIdProp];
                featureInfo.properties = featureData;
                featureInfo.configureDescriptionFromProperties(featureData);
                featureInfo.configureNameFromProperties(featureData);
                // If time-series region-mapping - show timeseries chart
                if (!isDefined(featureData._terria_getChartDetails) &&
                    this.discreteTimes &&
                    this.discreteTimes.length > 1 &&
                    Array.isArray(regionIds)) {
                    featureInfo.properties._terria_getChartDetails = getChartDetailsFn(this.activeTableStyle, regionIds);
                }
                return featureInfo;
            }
            return undefined;
        }
        getRowValues(index) {
            const result = {};
            this.tableColumns.forEach(column => {
                result[column.title] = column.valueFunctionForType(index);
            });
            return result;
        }
    }
    __decorate([
        observable
    ], TableMixin.prototype, "_dataColumnMajor", void 0);
    __decorate([
        observable
    ], TableMixin.prototype, "regionProviderList", void 0);
    __decorate([
        computed
    ], TableMixin.prototype, "dataColumnMajor", null);
    __decorate([
        computed
    ], TableMixin.prototype, "tableColumns", null);
    __decorate([
        computed
    ], TableMixin.prototype, "tableStyles", null);
    __decorate([
        computed
    ], TableMixin.prototype, "defaultTableStyle", null);
    __decorate([
        computed
    ], TableMixin.prototype, "activeStyle", null);
    __decorate([
        computed
    ], TableMixin.prototype, "activeTableStyle", null);
    __decorate([
        computed
    ], TableMixin.prototype, "xColumn", null);
    __decorate([
        computed
    ], TableMixin.prototype, "yColumns", null);
    __decorate([
        computed
    ], TableMixin.prototype, "disableOpacityControl", null);
    __decorate([
        computed
    ], TableMixin.prototype, "_canExportData", null);
    __decorate([
        computed
    ], TableMixin.prototype, "disableSplitter", null);
    __decorate([
        computed
    ], TableMixin.prototype, "disableZoomTo", null);
    __decorate([
        computed
    ], TableMixin.prototype, "mapItems", null);
    __decorate([
        computed
    ], TableMixin.prototype, "shortReport", null);
    __decorate([
        computed
    ], TableMixin.prototype, "regionMappedImageryParts", null);
    __decorate([
        computed
    ], TableMixin.prototype, "regionMappedImageryProvider", null);
    __decorate([
        computed
    ], TableMixin.prototype, "tableChartItems", null);
    __decorate([
        computed
    ], TableMixin.prototype, "chartItems", null);
    __decorate([
        computed
    ], TableMixin.prototype, "selectableDimensions", null);
    __decorate([
        computed
    ], TableMixin.prototype, "styleDimensions", null);
    __decorate([
        computed
    ], TableMixin.prototype, "regionProviderDimensions", null);
    __decorate([
        computed
    ], TableMixin.prototype, "regionColumnDimensions", null);
    __decorate([
        computed
    ], TableMixin.prototype, "rowIds", null);
    __decorate([
        computed
    ], TableMixin.prototype, "isSampled", null);
    __decorate([
        computed
    ], TableMixin.prototype, "discreteTimes", null);
    __decorate([
        computed
    ], TableMixin.prototype, "legends", null);
    __decorate([
        action
    ], TableMixin.prototype, "append", null);
    return TableMixin;
}
(function (TableMixin) {
    function isMixedInto(model) {
        return model && model.hasTableMixin;
    }
    TableMixin.isMixedInto = isMixedInto;
})(TableMixin || (TableMixin = {}));
export default TableMixin;
//# sourceMappingURL=TableMixin.js.map