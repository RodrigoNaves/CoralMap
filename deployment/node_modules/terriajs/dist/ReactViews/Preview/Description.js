import React from "react";
import createReactClass from "create-react-class";
import PropTypes from "prop-types";
import { withTranslation, Trans } from "react-i18next";
import defined from "terriajs-cesium/Source/Core/defined";
import Collapsible from "../Custom/Collapsible/Collapsible";
import DataPreviewSections from "./DataPreviewSections";
import DataUri from "../../Core/DataUri";
import MetadataTable from "./MetadataTable";
import parseCustomMarkdownToReact from "../Custom/parseCustomMarkdownToReact";
import Styles from "./mappable-preview.scss";
import { observer } from "mobx-react";
import ExportData from "./ExportData";
import WarningBox from "./WarningBox";
import Box from "../../Styled/Box";
import Button from "../../Styled/Button";
/**
 * CatalogItem description.
 */
const Description = observer(createReactClass({
    displayName: "Description",
    propTypes: {
        item: PropTypes.object.isRequired,
        printView: PropTypes.bool,
        t: PropTypes.func.isRequired
    },
    render() {
        var _a;
        const { t } = this.props;
        const catalogItem = this.props.item;
        const dataUrlType = catalogItem.dataUrlType;
        let hasDataUriCapability;
        let dataUri;
        let dataUriFormat;
        if (dataUrlType === "data-uri" || dataUrlType === "local") {
            hasDataUriCapability = DataUri.checkCompatibility();
            if (hasDataUriCapability) {
                dataUri = catalogItem.dataUrl;
                if (dataUri) {
                    dataUriFormat = getDataUriFormat(dataUri);
                }
            }
        }
        // Make sure all metadataUrls have `url` set
        const metadataUrls = (_a = catalogItem.metadataUrls) === null || _a === void 0 ? void 0 : _a.filter(m => m.url);
        return (React.createElement("div", { className: Styles.description, css: `
            a,
            a:visited {
              color: ${p => p.theme.colorPrimary};
            }
          ` },
            React.createElement(If, { condition: catalogItem.isExperiencingIssues },
                React.createElement(WarningBox, null, t("preview.mayBeExperiencingIssues"))),
            React.createElement(If, { condition: catalogItem.description && catalogItem.description.length > 0 },
                React.createElement("div", null,
                    React.createElement("h4", { className: Styles.h4 }, t("description.name")),
                    parseCustomMarkdownToReact(catalogItem.description, {
                        catalogItem: catalogItem
                    }))),
            React.createElement(If, { condition: catalogItem.hasLocalData },
                React.createElement("p", null, t("description.dataLocal"))),
            React.createElement(If, { condition: !catalogItem.hasLocalData && !catalogItem.hasDescription },
                React.createElement("p", null, t("description.dataNotLocal"))),
            React.createElement(If, { condition: metadataUrls && metadataUrls.length > 0 },
                React.createElement("h4", { className: Styles.h4 }, t("description.metadataUrls")),
                React.createElement(For, { each: "metadataUrl", index: "i", of: metadataUrls },
                    React.createElement(Box, { paddedVertically: true, key: metadataUrl.url },
                        React.createElement("a", { href: metadataUrl.url, target: "_blank", rel: "noopener noreferrer", className: `${Styles.link} description-metadataUrls`, css: `
                    color: ${p => p.theme.colorPrimary};
                  ` },
                            React.createElement(If, { condition: metadataUrl.title },
                                React.createElement(Button, { primary: true }, metadataUrl.title)),
                            React.createElement(If, { condition: !metadataUrl.title }, metadataUrl.url))))),
            React.createElement(DataPreviewSections, { metadataItem: catalogItem }),
            React.createElement(If, { condition: catalogItem.dataCustodian && catalogItem.dataCustodian.length > 0 },
                React.createElement("div", null,
                    React.createElement("h4", { className: Styles.h4 }, t("description.dataCustodian")),
                    parseCustomMarkdownToReact(catalogItem.dataCustodian, {
                        catalogItem: catalogItem
                    }))),
            React.createElement(If, { condition: !catalogItem.hideSource },
                React.createElement(If, { condition: catalogItem.url },
                    React.createElement("h4", { className: Styles.h4 },
                        catalogItem.typeName,
                        " URL"),
                    React.createElement(Choose, null,
                        React.createElement(When, { condition: catalogItem.type === "wms" },
                            React.createElement("p", { key: "wms-description" },
                                React.createElement(Trans, { i18nKey: "description.wms" },
                                    "This is a",
                                    React.createElement("a", { href: "https://en.wikipedia.org/wiki/Web_Map_Service", target: "_blank", rel: "noopener noreferrer" }, "WMS service"),
                                    ", which generates map images on request. It can be used in GIS software with this URL:"))),
                        React.createElement(When, { condition: catalogItem.type === "wfs" },
                            React.createElement("p", { key: "wfs-description" },
                                React.createElement(Trans, { i18nKey: "description.wfs" },
                                    "This is a",
                                    React.createElement("a", { href: "https://en.wikipedia.org/wiki/Web_Feature_Service", target: "_blank", rel: "noopener noreferrer" }, "WFS service"),
                                    ", which transfers raw spatial data on request. It can be used in GIS software with this URL:")))),
                    React.createElement(Choose, null,
                        React.createElement(When, { condition: this.props.printView },
                            React.createElement("code", null, catalogItem.url)),
                        React.createElement(Otherwise, null,
                            React.createElement("input", { readOnly: true, className: Styles.field, type: "text", value: catalogItem.url, onClick: e => e.target.select() }))),
                    React.createElement(Choose, null,
                        React.createElement(When, { condition: catalogItem.type === "wms" ||
                                (catalogItem.type === "esri-mapServer" &&
                                    defined(catalogItem.layers)) },
                            React.createElement("p", { key: "wms-layers" },
                                t("description.layerName"),
                                (catalogItem.layers || "").split(",").length > 1
                                    ? "s"
                                    : "",
                                ": ",
                                catalogItem.layers)),
                        React.createElement(When, { condition: catalogItem.type === "wfs" },
                            React.createElement("p", { key: "wfs-typeNames" },
                                t("description.typeName"),
                                (catalogItem.typeNames || "").split(",").length > 1
                                    ? "s"
                                    : "",
                                ": ",
                                catalogItem.typeNames)))),
                React.createElement(If, { condition: catalogItem.dataUrlType &&
                        catalogItem.dataUrlType !== "none" &&
                        catalogItem.dataUrl },
                    React.createElement("h4", { className: Styles.h4 }, t("description.dataUrl")),
                    React.createElement("p", null,
                        React.createElement(Choose, null,
                            React.createElement(When, { condition: catalogItem.dataUrlType.indexOf("wfs") === 0 ||
                                    catalogItem.dataUrlType.indexOf("wcs") === 0 },
                                catalogItem.dataUrlType.indexOf("wfs") === 0 &&
                                    t("description.useLinkBelow", {
                                        link: (React.createElement("a", { href: "http://docs.geoserver.org/latest/en/user/services/wfs/reference.html", target: "_blank", rel: "noopener noreferrer", key: "wfs" }, "Web Feature Service (WFS) documentation"))
                                    }),
                                catalogItem.dataUrlType.indexOf("wcs") === 0 &&
                                    t("description.useLinkBelow", {
                                        link: (React.createElement("a", { href: "http://docs.geoserver.org/latest/en/user/services/wcs/reference.html", target: "_blank", rel: "noopener noreferrer", key: "wms" }, "Web Coverage Service (WCS) documentation"))
                                    }),
                                React.createElement("br", null),
                                React.createElement(Link, { url: catalogItem.dataUrl, text: catalogItem.dataUrl })),
                            React.createElement(When, { condition: dataUrlType === "data-uri" || dataUrlType === "local" },
                                React.createElement(If, { condition: hasDataUriCapability },
                                    React.createElement(Link, { url: dataUri, text: t("description.downloadInFormat", {
                                            format: dataUriFormat.toUpperCase()
                                        }), download: getBetterFileName(dataUrlType, catalogItem.name, dataUriFormat) })),
                                React.createElement(If, { condition: !hasDataUriCapability }, t("description.downloadNotSupported"))),
                            React.createElement(Otherwise, null,
                                t("description.useTheLinkToDownload"),
                                React.createElement("br", null),
                                catalogItem.dataUrl.startsWith("data:") && (React.createElement(Link, { url: catalogItem.dataUrl, text: t("description.exportData") })),
                                !catalogItem.dataUrl.startsWith("data:") && (React.createElement(Link, { url: catalogItem.dataUrl, text: catalogItem.dataUrl })))))),
                React.createElement(If, { condition: !this.props.printView && defined(catalogItem.metadata) },
                    React.createElement(If, { condition: defined(catalogItem.metadata.dataSourceMetadata) &&
                            catalogItem.metadata.dataSourceMetadata.items.length > 0 },
                        React.createElement("div", { className: Styles.metadata },
                            React.createElement(Collapsible, { title: t("description.dataSourceDetails"), isInverse: true },
                                React.createElement(MetadataTable, { metadataItem: catalogItem.metadata.dataSourceMetadata })))),
                    React.createElement(If, { condition: defined(catalogItem.metadata.dataSourceMetadata) &&
                            catalogItem.metadata.dataSourceMetadata.items.length > 0 },
                        React.createElement("div", { className: Styles.metadata },
                            React.createElement(Collapsible, { title: t("description.dataServiceDetails"), isInverse: true },
                                React.createElement(MetadataTable, { metadataItem: catalogItem.metadata.serviceMetadata })))))),
            React.createElement(ExportData, { item: catalogItem })));
    }
}));
/**
 * Read the format from the start of a data uri, eg. data:attachment/csv,...
 * @param  {String} dataUri The data URI.
 * @return {String} The format string, eg. 'csv', or undefined if none found.
 */
function getDataUriFormat(dataUri) {
    if (defined(dataUri)) {
        const slashIndex = dataUri.indexOf("/");
        const commaIndex = dataUri.indexOf(",");
        // Don't look into the data itself. Assume the format is somewhere in the first 40 chars.
        if (slashIndex < commaIndex && commaIndex < 40) {
            return dataUri.slice(slashIndex + 1, commaIndex);
        }
    }
}
/**
 * Return a nicer filename for this file.
 * @private
 */
function getBetterFileName(dataUrlType, itemName, format) {
    let name = itemName;
    const extension = "." + format;
    // Only add the extension if it's not already there.
    if (name.indexOf(extension) !== name.length - extension.length) {
        name = name + extension;
    }
    // For local files, the file already exists on the user's computer with the original name, so give it a modified name.
    if (dataUrlType === "local") {
        name = "processed " + name;
    }
    return name;
}
const Link = observer(createReactClass({
    displayName: "Link",
    propTypes: {
        url: PropTypes.string.isRequired,
        text: PropTypes.string.isRequired,
        download: PropTypes.string
    },
    render() {
        return (React.createElement("a", { href: this.props.url, className: Styles.link, download: this.props.download, target: "_blank", rel: "noopener noreferrer" }, this.props.text));
    }
}));
export default withTranslation()(Description);
//# sourceMappingURL=Description.js.map